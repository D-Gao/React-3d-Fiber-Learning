/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/models/Koi_01.glb -o src/models/FishBoid.tsx --typescript -r public 
*/

import * as THREE from "three";
import React, { useEffect, useMemo, useRef } from "react";
import { useFrame, useGraph, useThree } from "@react-three/fiber";
import { useGLTF, useAnimations, shaderMaterial } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import { getDeformedVertices, nextPowerOf2 } from "@/experiences/Boid/utils";
import { GPUComputationRenderer } from "three/examples/jsm/misc/GPUComputationRenderer.js";
import computeVelocityShader from "@/experiences/Boid/shaders/computeVelocityShader.glsl";
import computePositionShader from "@/experiences/Boid/shaders/computePositionShader.glsl";
import { lerp } from "three/src/math/MathUtils.js";

type ActionName =
  | "Fish_Armature|Attack"
  | "Fish_Armature|Death"
  | "Fish_Armature|Out_Of_Water"
  | "Fish_Armature|Swimming_Fast"
  | "Fish_Armature|Swimming_Impulse"
  | "Fish_Armature|Swimming_Normal";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    Koi_01: THREE.SkinnedMesh;
    Main1: THREE.Bone;
    Main7: THREE.Bone;
    Main8: THREE.Bone;
  };
  materials: {
    "Koi_01.001": THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

// the size of the gpgpu texture so the total boid size is 64
const size = 8;
const BOIDSCOUNT = size ** 2;
const BOUNDS = 400;
const BOUNDS_HALF = 400 / 2;

export function FishBoid(props: JSX.IntrinsicElements["group"]) {
  const tempMap = useRef();
  const pointsRef = useRef<THREE.Points>(null);
  const { gl, camera, scene: totalscene } = useThree();
  const group = React.useRef<THREE.Group>(null);
  const { scene, nodes, materials, animations } = useGLTF("/models/Koi_01.glb");

  const mixerRef = useRef<THREE.AnimationMixer>();
  const textureAnimation = useRef<THREE.DataTexture>();

  //update the animation matrix which is a vertices  x animation key frames 2-d matrix
  //so each i row represents the vertex's relative morph position respect to the original position at key frame i
  useEffect(() => {
    console.log(nodes); // Check if any rotations are being applied
    console.log(materials);
    if (!group.current) return;
    mixerRef.current = new THREE.AnimationMixer(nodes.Koi_01);
    const clip = animations[12];
    const action = mixerRef.current.clipAction(clip);

    action.play();

    const times = clip.duration;
    const keyframes = Array.from({ length: 10 }, (_, i) => {
      return (times / 10) * (i + 1);
    });

    const allRelativePositions: { positions: THREE.Vector3[]; time: number }[] =
      [];
    keyframes.forEach((Keyframe) => {
      mixerRef.current!.setTime(Keyframe);
      mixerRef.current!.update(0);

      // Access the geometry after skeletal deformation at this time
      const skinnedGeometry = (nodes.Koi_01 as THREE.SkinnedMesh).geometry;
      const positionAttribute = skinnedGeometry.attributes.position;
      (nodes.Koi_01 as THREE.SkinnedMesh).skeleton.update();

      gl.render(totalscene, camera);
      const relativePositions = getDeformedVertices(
        nodes.Koi_01 as THREE.SkinnedMesh
      );
      //console.log(positionAttribute);

      allRelativePositions.push({
        positions: relativePositions,
        time: Keyframe,
      });
    });
    const morphAttributes = allRelativePositions.map((morph) => {
      return morph.positions;
    });

    //console.log(morphAttributes);
    // fill the animation texture with width equal to vertex count and
    // height equal to number of animation keyframes
    // but need to set the widht and height to the power of 2
    const durationAnimation = Math.round(clip.duration * 60);
    const birdGeo = (nodes.Koi_01 as THREE.SkinnedMesh).geometry;
    /* birdGeo.rotateZ(Math.PI / 2); */
    // if duration is 7 then tHeight will be 8 (since it is the next power of 2 number for 7)
    const tHeight = nextPowerOf2(durationAnimation);
    const tWidth = nextPowerOf2(birdGeo.getAttribute("position").count);
    /* //console.log(tHeight);
    //console.log(tWidth); */
    const tData = new Float32Array(4 * tWidth * tHeight);
    for (let i = 0; i < birdGeo.getAttribute("position").count; i++) {
      for (let j = 0; j < tHeight; j++) {
        const offset = j * tWidth * 4;

        const curMorph = Math.floor(
          (j / durationAnimation) * morphAttributes.length
        );
        const nextMorph =
          (Math.floor((j / durationAnimation) * morphAttributes.length) + 1) %
          morphAttributes.length;
        const lerpAmount =
          ((j / durationAnimation) * morphAttributes.length) % 1;

        if (j < durationAnimation) {
          let d0, d1;

          const currentVex = morphAttributes[curMorph][i].clone();
          const nextVex = morphAttributes[nextMorph][i].clone();

          d0 = currentVex.x;
          d1 = nextVex.x;
          if (d0 !== undefined && d1 !== undefined)
            tData[offset + i * 4] = lerp(d0, d1, lerpAmount);

          d0 = currentVex.y;
          d1 = nextVex.y;
          if (d0 !== undefined && d1 !== undefined)
            tData[offset + i * 4 + 1] = lerp(d0, d1, lerpAmount);

          d0 = currentVex.z;
          d1 = nextVex.z;

          if (d0 !== undefined && d1 !== undefined)
            tData[offset + i * 4 + 2] = lerp(d0, d1, lerpAmount);

          tData[offset + i * 4 + 3] = 1;
        }
      }
    }

    textureAnimation.current = new THREE.DataTexture(
      tData,
      tWidth,
      tHeight,
      THREE.RGBAFormat,
      THREE.FloatType
    );
    textureAnimation.current.needsUpdate = true;

    /* pointsRef.current!.geometry = new THREE.BufferGeometry();

    const positions = allRelativePositions[0].positions;

    const positionsArray = new Float32Array(positions.length * 3);

    const skinnedGeometry = (nodes.Koi_01 as THREE.SkinnedMesh).geometry;
    const originalPositionAttribute = skinnedGeometry.attributes.position.array;

    positions.forEach((vector, index) => {
      positionsArray[index * 3] =
        originalPositionAttribute[index * 3] + vector.x;
      positionsArray[index * 3 + 1] =
        originalPositionAttribute[index * 3 + 1] + vector.y;
      positionsArray[index * 3 + 2] =
        originalPositionAttribute[index * 3 + 2] + vector.z;
    });

    const tempBufferAttribute = new THREE.Float32BufferAttribute(
      positionsArray,
      3
    );
    pointsRef.current!.geometry.setAttribute("position", tempBufferAttribute); */

    //creaate the points
  }, []);

  //gpgpu part
  const materialShader = useRef<THREE.WebGLProgramParametersWithUniforms>();
  const gpgpu = useMemo(() => new GPUComputationRenderer(size, size, gl), [gl]);

  //create base texture for both birds' velocity and position
  const dtVelocity = useMemo(() => {
    const baseTexture = gpgpu.createTexture();

    const data = baseTexture.image.data;
    for (let i = 0; i < data.length; i++) {
      const x = Math.random() - 0.5;
      const y = Math.random() - 0.5;
      const z = Math.random() - 0.5;

      data[i * 4 + 0] = x * 10;
      data[i * 4 + 1] = y * 10;
      data[i * 4 + 2] = z * 10;
      data[i * 4 + 3] = 1;
    }
    return baseTexture;
  }, [gpgpu]);
  const dtPosition = useMemo(() => {
    const baseTexture = gpgpu.createTexture();

    const data = baseTexture.image.data;
    for (let i = 0; i < data.length; i++) {
      const x = Math.random() * BOUNDS - BOUNDS_HALF;
      const y = Math.random() * BOUNDS - BOUNDS_HALF;
      const z = Math.random() * BOUNDS - BOUNDS_HALF;

      data[i * 4 + 0] = x;
      data[i * 4 + 1] = y;
      data[i * 4 + 2] = z;
      data[i * 4 + 3] = 1;
    }
    return baseTexture;
  }, [gpgpu]);
  //create variable based on compute shader and base texture
  const positionVariable = useMemo(() => {
    const temp = gpgpu.addVariable(
      "texturePosition",
      computePositionShader,
      dtPosition
    );
    temp.wrapS = THREE.RepeatWrapping;
    temp.wrapT = THREE.RepeatWrapping;
    temp.material.uniforms = {
      delta: {
        value: 0,
      },
      time: {
        value: 0,
      },
    };

    return temp;
  }, [gpgpu, dtPosition]);
  const velocityVariable = useMemo(() => {
    const temp = gpgpu.addVariable(
      "textureVelocity",
      computeVelocityShader,
      dtVelocity
    );
    temp.wrapS = THREE.RepeatWrapping;
    temp.wrapT = THREE.RepeatWrapping;
    temp.material.uniforms = {
      delta: {
        value: 0,
      },
      time: {
        value: 1,
      },
      testing: {
        value: 1,
      },
      separationDistance: {
        value: 1,
      },
      alignmentDistance: {
        value: 1,
      },
      cohesionDistance: {
        value: 1,
      },
      freedomFactor: {
        value: 1,
      },
      predator: {
        value: new THREE.Vector3(),
      },
    };
    temp.material.defines.BOUNDS = BOUNDS.toFixed(2);

    return temp;
  }, [gpgpu, dtVelocity]);

  const boidsGeometry = useRef<THREE.BufferGeometry>(
    new THREE.BufferGeometry()
  );

  useEffect(() => {
    gpgpu.setVariableDependencies(velocityVariable, [
      positionVariable,
      velocityVariable,
    ]);
    gpgpu.setVariableDependencies(positionVariable, [
      positionVariable,
      velocityVariable,
    ]);
    //initialize the gpgpu
    gpgpu.init();

    //
    const clip = animations[3];
    // consider this to be the number of frames for the current animation clip, for example 1 sec has 60 frames
    const durationAnimation = Math.round(clip.duration * 60);
    const birdGeo = (nodes.Koi_01 as THREE.SkinnedMesh).geometry;
    /* birdGeo.rotateZ(Math.PI / 2); */
    // if duration is 7 then tHeight will be 8 (since it is the next power of 2 number for 7)
    const tHeight = nextPowerOf2(durationAnimation);
    const tWidth = nextPowerOf2(birdGeo.getAttribute("position").count);
    const vertices = [],
      /* color = [], */
      reference = [],
      seeds = [],
      indices = [],
      uv = [];

    const totalVertices =
      birdGeo.getAttribute("position").count * 3 * BOIDSCOUNT;
    for (let i = 0; i < totalVertices; i++) {
      const bIndex = i % (birdGeo.getAttribute("position").count * 3);
      vertices.push(birdGeo.getAttribute("position").array[bIndex]);
    }

    const totalUV = birdGeo.getAttribute("uv").count * 2 * BOIDSCOUNT;

    for (let i = 0; i < totalUV; i++) {
      const bIndex = i % (birdGeo.getAttribute("uv").count * 2);
      uv.push(birdGeo.getAttribute("uv").array[bIndex]);
    }

    let r = Math.random();
    for (
      let i = 0;
      i < birdGeo.getAttribute("position").count * BOIDSCOUNT;
      i++
    ) {
      //the ith boid's corrisponding ith vertex index( inner boid)
      const bIndex = i % birdGeo.getAttribute("position").count;
      //the index of ith boid (boids group)
      const bird = Math.floor(i / birdGeo.getAttribute("position").count);
      if (bIndex == 0) r = Math.random();
      const j = ~~bird;

      //equivalient of uv coordinate in the boids texture, x, y identify a boid
      //bIndex / tWidth identify the vertex in side the given boid
      //durationAnimation / tHeight fixed value
      const x = (j % size) / size;
      const y = ~~(j / size) / size;
      reference.push(x, y, bIndex / tWidth, (durationAnimation + 23) / tHeight);
      seeds.push(bird, r, Math.random(), Math.random());
    }

    //adjust the corrisponding indexes
    for (let i = 0; i < birdGeo.index!.array.length * BOIDSCOUNT; i++) {
      const offset =
        Math.floor(i / birdGeo.index!.array.length) *
        birdGeo.getAttribute("position").count;
      indices.push(
        birdGeo.index!.array[i % birdGeo.index!.array.length] + offset
      );
    }

    boidsGeometry.current.setAttribute(
      "uv",
      new THREE.BufferAttribute(new Float32Array(uv), 2)
    );

    boidsGeometry.current.setAttribute(
      "position",
      new THREE.BufferAttribute(new Float32Array(vertices), 3)
    );
    boidsGeometry.current.setAttribute(
      "reference",
      new THREE.BufferAttribute(new Float32Array(reference), 4)
    );
    boidsGeometry.current.setAttribute(
      "seeds",
      new THREE.BufferAttribute(new Float32Array(seeds), 4)
    );

    boidsGeometry.current.setIndex(indices);

    //init boids

    const geometry = boidsGeometry.current;
    (materials["Koi_01.001"] as THREE.MeshStandardMaterial).map!.wrapS =
      THREE.RepeatWrapping;
    (materials["Koi_01.001"] as THREE.MeshStandardMaterial).map!.wrapT =
      THREE.RepeatWrapping;
    const m = new THREE.MeshStandardMaterial({
      map: (materials["Koi_01.001"] as THREE.MeshStandardMaterial).map,
    });

    const birdMesh = new THREE.Mesh(geometry, m);
    birdMesh.frustumCulled = false;
    totalscene.add(birdMesh);
    //return;
    //customize the materials shader
    m.onBeforeCompile = (shader) => {
      shader.uniforms.texturePosition = { value: null };
      shader.uniforms.textureVelocity = { value: null };
      shader.uniforms.textureAnimation = { value: textureAnimation.current };
      shader.uniforms.time = { value: 0.0 };
      shader.uniforms.size = { value: 1.0 };
      shader.uniforms.delta = { value: 0.0 };

      let token = "#define STANDARD";

      let insert = /* glsl */ `
						attribute vec4 reference;
						attribute vec4 seeds;
						attribute vec3 birdColor;
						uniform sampler2D texturePosition;
						uniform sampler2D textureVelocity;
						uniform sampler2D textureAnimation;
						uniform float size;
						uniform float time;
            const float PI = 3.141592653589793;
					`;

      shader.vertexShader = shader.vertexShader.replace(token, token + insert);

      token = "#include <begin_vertex>";

      insert = /* glsl */ `
						/* vec4 tmpPos = texture2D( texturePosition, reference.xy );

						vec3 pos = tmpPos.xyz;
						vec3 velocity = normalize(texture2D( textureVelocity, reference.xy ).xyz);
						vec3 aniPos = texture2D( textureAnimation, vec2( reference.z, mod( time + ( seeds.x ) * ( ( 0.0004 + seeds.y / 10000.0) + normalize( velocity ) / 20000.0 ), reference.w ) ) ).xyz;
						vec3 newPosition = position;

						newPosition = mat3( modelMatrix ) * ( newPosition + aniPos );
						newPosition *= size + seeds.y * size * 0.2;

						velocity.z *= -1.;
						float xz = length( velocity.xz );
						float xyz = 1.;
						float x = sqrt( 1. - velocity.y * velocity.y );

						float cosry = velocity.x / xz;
						float sinry = velocity.z / xz;

						float cosrz = x / xyz;
						float sinrz = velocity.y / xyz;

						mat3 maty =  mat3( cosry, 0, -sinry, 0    , 1, 0     , sinry, 0, cosry );
						mat3 matz =  mat3( cosrz , sinrz, 0, -sinrz, cosrz, 0, 0     , 0    , 1 );

						newPosition =  maty * matz * newPosition;
						newPosition += pos;

						vec3 transformed = vec3( newPosition ); */
            vec4 tmpPos = texture2D( texturePosition, reference.xy );
            vec3 pos = tmpPos.xyz;
            vec3 newPosition = position;
            

            vec3 velocity = normalize(texture2D( textureVelocity, reference.xy ).xyz);
            vec3 aniPos = texture2D( textureAnimation, vec2( reference.z,   mod( time , reference.w ) ) ).xyz;
            //velocity.z *= -1.;
            newPosition = mat3( modelMatrix ) * ( newPosition + aniPos );
            velocity.y *= -1.;
						float xz = length( velocity.xz );
            float xy = length( velocity.xy );
            float yz = length( velocity.yz );
						float xyz = 1.;
						float x = sqrt( 1. - velocity.y * velocity.y );

						float cosry = velocity.x / xz;
						float sinry = velocity.z /  xz;

            float cosrz = x / xyz;
						float sinrz = velocity.y / xyz;

						mat3 maty =  mat3( cosry, 0, sinry, 0    , 1, 0     , -sinry, 0, cosry );
						mat3 matz =  mat3( cosrz , -sinrz, 0, sinrz, cosrz, 0, 0     , 0    , 1 );

            newPosition =  maty *matz  *newPosition;
            newPosition += pos/50.0;
           
            vec3 transformed = vec3( newPosition );
					`;

      shader.vertexShader = shader.vertexShader.replace(token, insert);

      materialShader.current = shader;
    };
  }, [gpgpu, positionVariable, velocityVariable]);

  useFrame((state, delta) => {
    //NOTE!!!!!! it is important to update the compute shader before .compute() function is called
    positionVariable.material.uniforms.time.value += delta;

    positionVariable.material.uniforms.delta.value = delta;
    velocityVariable.material.uniforms.time.value += delta;
    velocityVariable.material.uniforms.delta.value = delta;
    gpgpu.compute();
    //NOTE!!!!!! normal shader need to be updated after .compute() function is called
    if (materialShader.current) {
      materialShader.current.uniforms.texturePosition.value =
        gpgpu.getCurrentRenderTarget(positionVariable).texture;
      materialShader.current.uniforms.textureVelocity.value =
        gpgpu.getCurrentRenderTarget(velocityVariable).texture;

      materialShader.current.uniforms.time.value = state.clock.elapsedTime / 1;
      materialShader.current.uniforms.delta.value = delta;
    }

    /* tempMap.current = gpgpu.getCurrentRenderTarget(positionVariable).texture; */
    /* //console.log(gpgpu.getCurrentRenderTarget(positionVariable).texture); */
  });

  return (
    <>
      <group ref={group} {...props} dispose={null}>
        <group name="Scene" visible={false}>
          <group
            name="Fish_Armature"
            scale={15.017}
            rotation={[-Math.PI / 2, 0, Math.PI / 2]}
          >
            <primitive object={nodes.Main1} />
            <primitive object={nodes.Main7} />
            <primitive object={nodes.Main8} />
            <skinnedMesh
              name="Koi_01"
              geometry={nodes.Koi_01.geometry}
              material={materials.Koi_01}
              skeleton={nodes.Koi_01.skeleton}
            />
          </group>
        </group>
      </group>
      {/* <mesh>
        <planeGeometry></planeGeometry>
        <meshBasicMaterial map={tempMap.current}></meshBasicMaterial>
      </mesh> */}
      <points ref={pointsRef} scale={1} position={[0, 0, 0]}>
        <pointsMaterial size={0.02}></pointsMaterial>
      </points>
    </>
  );
}

useGLTF.preload("/models/Koi_01.glb");
