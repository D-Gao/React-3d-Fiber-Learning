/* eslint-disable @typescript-eslint/no-unsafe-argument */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/models/car.glb -o src/models/CarM.tsx --typescript -r public 
*/

import * as THREE from "three";
import React, { useEffect, useMemo, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame, useThree } from "@react-three/fiber";
import { instance } from "three/examples/jsm/nodes/Nodes.js";
import gsap from "gsap";
import Curves from "@/assets/output_file.json";
import vertexShader from "@/experiences/Car/shaders/line/vertexShader.glsl";
import fragmentShader from "@/experiences/Car/shaders/line/fragmentShader.glsl";
import { useControls } from "leva";
import { BufferGeometryUtils } from "three/examples/jsm/Addons.js";
import { MeshBVH, MeshBVHHelper, CONTAINED } from "three-mesh-bvh";

type GLTFResult = GLTF & {
  nodes: {
    Object_4: THREE.Mesh;
    Object_6: THREE.Mesh;
    Object_8: THREE.Mesh;
    Object_31: THREE.Mesh;
    Object_32: THREE.Mesh;
    Object_33: THREE.Mesh;
    Object_34: THREE.Mesh;
    Object_35: THREE.Mesh;
    Object_36: THREE.Mesh;
    Object_38: THREE.Mesh;
    Object_39: THREE.Mesh;
    Object_40: THREE.Mesh;
    Object_41: THREE.Mesh;
    Object_42: THREE.Mesh;
    Object_44: THREE.Mesh;
    Object_45: THREE.Mesh;
    Object_46: THREE.Mesh;
    Object_47: THREE.Mesh;
    Object_48: THREE.Mesh;
    Object_49: THREE.Mesh;
    Object_51: THREE.Mesh;
    Object_52: THREE.Mesh;
    Object_53: THREE.Mesh;
    Object_54: THREE.Mesh;
    Object_10: THREE.Mesh;
    Object_12: THREE.Mesh;
    Object_13: THREE.Mesh;
    Object_14: THREE.Mesh;
    Object_16: THREE.Mesh;
    Object_18: THREE.Mesh;
    Object_19: THREE.Mesh;
    Object_20: THREE.Mesh;
    Object_21: THREE.Mesh;
    Object_22: THREE.Mesh;
    Object_23: THREE.Mesh;
    Object_24: THREE.Mesh;
    Object_25: THREE.Mesh;
    Object_27: THREE.Mesh;
    Object_28: THREE.Mesh;
    Object_29: THREE.Mesh;
    Object_56001: THREE.Mesh;
    Object_56002: THREE.Mesh;
    Object_56003: THREE.Mesh;
    Object_56004: THREE.Mesh;
    平面: THREE.Mesh;
    topLigt: THREE.Mesh;
  };
  materials: {
    ["interior1.002"]: THREE.MeshStandardMaterial;
    ["interior2.002"]: THREE.MeshStandardMaterial;
    ["M_BODY_inside.001"]: THREE.MeshStandardMaterial;
    ["Car_body.001"]: THREE.MeshPhysicalMaterial;
    ["M_BODY_black.001"]: THREE.MeshStandardMaterial;
    ["M_IRON.001"]: THREE.MeshStandardMaterial;
    ["interior3.002"]: THREE.MeshStandardMaterial;
    ["Car_window.001"]: THREE.MeshPhysicalMaterial;
    ["interior4.002"]: THREE.MeshStandardMaterial;
    ["M_ChePai.001"]: THREE.MeshStandardMaterial;
    ["M_LOGO.001"]: THREE.MeshStandardMaterial;
    ["Car_backlight.001"]: THREE.MeshStandardMaterial;
    ["Car_lightglass.001"]: THREE.MeshStandardMaterial;
    ["Car_frontlight.001"]: THREE.MeshStandardMaterial;
    ["Car_radar.001"]: THREE.MeshStandardMaterial;
    ["pasted__M_BODY_inside.002"]: THREE.MeshStandardMaterial;
    ["M_Wheel_ALL.001"]: THREE.MeshStandardMaterial;
    floor: THREE.MeshPhysicalMaterial;
    Material_18: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

interface BVHBufferGEometry
  extends THREE.BufferGeometry<THREE.NormalBufferAttributes> {
  boundsTree: MeshBVH;
}

export function CarM(props: JSX.IntrinsicElements["group"]) {
  const state = useThree();
  const { nodes, materials, scene } = useGLTF("/models/car.glb") as GLTFResult;
  const wheelRef = useRef<THREE.Group<THREE.Object3DEventMap>>(null);
  const carBody = useRef<THREE.Group<THREE.Object3DEventMap>>(null);
  const ref = useRef<THREE.Group<THREE.Object3DEventMap>>(null);

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const outlineLines = useRef<THREE.LineSegments>();
  const colliderBvh = useRef<MeshBVH>();

  const clip = useRef(new THREE.Plane());
  const clip2 = useRef(new THREE.Plane());

  const { CONSTANT } = useControls("Clip Plane Control", {
    CONSTANT: { value: 8, min: -10, max: 8, step: 0.1 },
    //RUN_SPEED: { value: 1.6, min: 0.2, max: 12, step: 0.1 },
  });

  useEffect(() => {
    clip.current.constant = CONSTANT;
    clip2.current.constant = -CONSTANT;
  }, [CONSTANT]);

  const material = useRef(
    new THREE.ShaderMaterial({
      side: THREE.DoubleSide,
      uniforms: {
        vTime: { value: 0 },
        color: { value: new THREE.Color(0.2, 0.8, 1) },
        vProgress: { value: 0.8 },
        uSize: { value: 7 },
      },
      transparent: true,
      // depthTest: false,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      clippingPlanes: [clip2.current],
      clipping: true,
    })
  );
  const initCurves = () => {
    const curves: THREE.CatmullRomCurve3[] = [];
    Curves.points.forEach((path) => {
      const points = [];
      // eslint-disable-next-line @typescript-eslint/prefer-for-of
      for (let i = 0; i < path.length; i++) {
        points.push(new THREE.Vector3(path[i].x, path[i].y, path[i].z));
      }
      const tempcurve = new THREE.CatmullRomCurve3(points);
      curves.push(tempcurve);
    });

    const radius = 0.005;
    const radialSegments = 3;
    curves.forEach((path, index) => {
      const geometry = new THREE.TubeGeometry(
        path,
        32,
        radius,
        radialSegments,
        false
      );
      const line = new THREE.Mesh(geometry, material.current);
      ref.current!.scale.set(1, 1, 1);
      ref.current!.position.y = 0.0;
      // line.scale.set(0.1, 0.1, 0.1)
      ref.current!.add(line);
      //console.log(ref.current);
    });
  };

  useEffect(() => {
    clip.current.normal.set(-1, 0, 0);
    clip2.current.normal.set(1, 0, 0);
    /* clip.current.constant = -8; */

    carBody.current?.traverse((item) => {
      if (item instanceof THREE.Mesh) {
        (item.material as THREE.MeshStandardMaterial).clippingPlanes = [
          clip.current,
        ];
      }
    });
    initCurves();
  }, []);

  useFrame((state, delta) => {
    /* CustomTunnelMaterial.uniforms.time.value = state.clock.getElapsedTime();
    cubeCamera.update(state.gl, state.scene); */
    /* wheelRef.current?.rotateX(state.clock.getElapsedTime() * -0.001); */
    wheelRef.current?.children.forEach((item) => {
      (item as THREE.Mesh).rotateX(delta * -10);
    });

    material.current.uniforms.vTime.value += delta;
  });

  //outline helper functions

  //create the merged mesh from the original one
  function dealModel() {
    let mergedGeometry = new THREE.BufferGeometry();
    // 存储所有模型的几何体
    const geometries: THREE.BufferGeometry[] = [];
    scene.traverse((item) => {
      if (item instanceof THREE.Mesh) {
        console.log(item);
        if (item.name === "平面" || item.name === "topLigt") return;

        const instanceGeo = (item as THREE.Mesh).geometry.clone();
        // it is necessary since geometry has no transformation data
        // and it will result in a wrong merge
        instanceGeo.applyMatrix4(item.matrix);
        if (!instanceGeo.getAttribute("uv1")) {
          // Create a default uv1 attribute (can be zeros or a copy of 'uv')
          const uv1Array = new Float32Array(
            instanceGeo.attributes.position.count * 2
          );
          instanceGeo.setAttribute(
            "uv1",
            new THREE.BufferAttribute(uv1Array, 2)
          );
        }
        if (!instanceGeo.getAttribute("uv2")) {
          // Create a default uv1 attribute (can be zeros or a copy of 'uv')
          const uv1Array = new Float32Array(
            instanceGeo.attributes.position.count * 2
          );
          instanceGeo.setAttribute(
            "uv2",
            new THREE.BufferAttribute(uv1Array, 2)
          );
        }
        if (!instanceGeo.getAttribute("uv3")) {
          // Create a default uv1 attribute (can be zeros or a copy of 'uv')
          const uv1Array = new Float32Array(
            instanceGeo.attributes.position.count * 2
          );
          instanceGeo.setAttribute(
            "uv3",
            new THREE.BufferAttribute(uv1Array, 2)
          );
        }
        geometries.push(instanceGeo);
      }
    });

    // 合并几何体
    if (geometries.length > 0) {
      console.log(geometries);
      mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
    }

    // 创建一个新的 Mesh 对象并设置合并后的几何体
    const mergedMesh = new THREE.Mesh(
      mergedGeometry,
      new THREE.MeshBasicMaterial({ color: "0xffff00" })
    );
    mergedMesh.scale.set(0.01 * 2.342, 0.01 * 2.342, 0.01 * 2.342);
    console.log(mergedMesh.matrix);
    mergedMesh.rotation.set(Math.PI / 2, 0, Math.PI / 2);
    mergedGeometry.applyMatrix4(mergedMesh.matrix);
    mergedMesh.position.y = 0.0;
    //mergedMesh.applyMatrix4(scene.matrix);
    //state.scene.add(mergedMesh);

    return mergedMesh;
  }

  function initLines(model: THREE.Mesh) {
    // create line geometry with enough data to hold 100000 segments
    const lineGeometry = new THREE.BufferGeometry();
    const linePosAttr = new THREE.BufferAttribute(
      new Float32Array(300000),
      3,
      false
    );
    linePosAttr.setUsage(THREE.DynamicDrawUsage);
    lineGeometry.setAttribute("position", linePosAttr);
    const outlineLines = new THREE.LineSegments(
      lineGeometry,
      new THREE.LineBasicMaterial()
    );
    const colorTemp = new THREE.Color(0x00acc1).multiplyScalar(30);
    outlineLines.material.color.set(colorTemp);
    outlineLines.frustumCulled = false;
    outlineLines.renderOrder = 3;

    outlineLines.scale.copy(model.scale);
    outlineLines.position.set(0, 0, 0);
    outlineLines.quaternion.identity();

    return outlineLines;
  }

  function initBvh(model: THREE.Mesh) {
    const mergedGeometry = model.geometry.clone();
    console.log(model.matrix);
    const rotationMatrix = new THREE.Matrix4().makeRotationX(Math.PI / 2);
    const rotationMatriz = new THREE.Matrix4().makeRotationZ(Math.PI / 2);

    mergedGeometry.applyMatrix4(rotationMatrix.multiply(rotationMatriz));

    const colliderBvh = new MeshBVH(mergedGeometry, { maxLeafTris: 3 });
    (mergedGeometry as BVHBufferGEometry).boundsTree = colliderBvh;

    const colliderMesh = new THREE.Mesh(
      mergedGeometry,
      new THREE.MeshBasicMaterial({
        wireframe: false,
        transparent: true,
        opacity: 0.1,
        depthWrite: false,
      })
    );
    colliderMesh.renderOrder = 2;
    colliderMesh.position.copy(model.position);
    //colliderMesh.rotation.copy(model.rotation);

    colliderMesh.visible = false;
    colliderMesh.scale.copy(model.scale);

    const bvhHelper = new MeshBVHHelper(colliderMesh, 1);
    bvhHelper.depth = 1;
    bvhHelper.update();

    return { colliderBvh, colliderMesh, bvhHelper };
  }

  //outline
  useEffect(() => {
    const mergedMesh = dealModel();
    outlineLines.current = initLines(mergedMesh);

    const { colliderBvh: temp, colliderMesh, bvhHelper } = initBvh(mergedMesh);
    colliderBvh.current = temp;
    ref.current!.add(colliderMesh, outlineLines.current);

    return () => {
      mergedMesh.geometry.dispose();
      mergedMesh.material.dispose();
      state.scene.remove(mergedMesh);
    };
  }, []);

  useFrame((_, defaultDelta) => {
    /* const delta = Math.min(defaultDelta, 0.03); */

    const clippingPlane = new THREE.Plane();
    clippingPlane.copy(clip.current);
    clippingPlane.constant = CONSTANT * 42.7;
    //clip.current.constant = -5;
    //clippingPlane.normal.set(0, 0, this.params.invert ? 1 : -1);
    //clippingPlane.constant = 0;
    //clippingPlane.applyMatrix4(this.planeMesh.matrixWorld);
    const tempLine = new THREE.Line3();
    const tempVector = new THREE.Vector3();
    const tempVector1 = new THREE.Vector3();
    const tempVector2 = new THREE.Vector3();
    const tempVector3 = new THREE.Vector3();
    let index = 0;
    const posAttr = outlineLines.current?.geometry.attributes.position;

    colliderBvh.current?.shapecast({
      intersectsBounds: (box) => {
        // if we're not using the BVH then skip straight to iterating over all triangles
        /* if (!this.params.useBVH) {
            return CONTAINED;
          } */
        return clippingPlane.intersectsBox(box);
      },
      intersectsTriangle: (tri) => {
        // check each triangle edge to see if it intersects with the plane. If so then
        // add it to the list of segments.
        let count = 0;
        tempLine.start.copy(tri.a);
        tempLine.end.copy(tri.b);
        if (clippingPlane.intersectLine(tempLine, tempVector)) {
          posAttr?.setXYZ(index, tempVector.x, tempVector.y, tempVector.z);
          index++;
          count++;
        }

        tempLine.start.copy(tri.b);
        tempLine.end.copy(tri.c);
        if (clippingPlane.intersectLine(tempLine, tempVector)) {
          posAttr?.setXYZ(index, tempVector.x, tempVector.y, tempVector.z);
          count++;
          index++;
        }

        tempLine.start.copy(tri.c);
        tempLine.end.copy(tri.a);
        if (clippingPlane.intersectLine(tempLine, tempVector)) {
          posAttr?.setXYZ(index, tempVector.x, tempVector.y, tempVector.z);
          count++;
          index++;
        }

        // When the plane passes through a vertex and one of the edges of the triangle, there will be three intersections, two of which must be repeated
        if (count === 3) {
          tempVector1.fromBufferAttribute(posAttr!, index - 3);
          tempVector2.fromBufferAttribute(posAttr!, index - 2);
          tempVector3.fromBufferAttribute(posAttr!, index - 1);
          // If the last point is a duplicate intersection
          if (
            tempVector3.equals(tempVector1) ||
            tempVector3.equals(tempVector2)
          ) {
            count--;
            index--;
          } else if (tempVector1.equals(tempVector2)) {
            // If the last point is not a duplicate intersection
            // Set the penultimate point as a distinct point and delete the last point
            posAttr!.setXYZ(
              index - 2,
              tempVector3.x,
              tempVector3.y,
              tempVector3.z
            );
            count--;
            index--;
          }
        }

        // If we only intersected with one or three sides then just remove it. This could be handled
        // more gracefully.
        if (count !== 2) {
          index -= count;
        }
      },
    });

    // set the draw range to only the new segments and offset the lines so they don't intersect with the geometry
    outlineLines.current!.geometry.setDrawRange(0, index);
    /* this.outlineLines.position
        .copy(clippingPlane.normal)
        .multiplyScalar(-0.00001); */
    posAttr!.needsUpdate = true;
  });

  return (
    <group {...props} dispose={null}>
      <group
        {...props}
        dispose={null}
        ref={ref}
        /*  rotation={[-Math.PI / 2, 0, -Math.PI / 2]} */
        scale={0.1}
      ></group>

      <group
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
        scale={2.342}
        ref={carBody}
      >
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <mesh
              geometry={nodes.Object_31.geometry}
              material={materials["M_BODY_inside.001"]}
            />
            <mesh
              geometry={nodes.Object_32.geometry}
              material={materials["Car_body.001"]}
            />
            <mesh
              geometry={nodes.Object_33.geometry}
              material={materials["M_BODY_black.001"]}
            />
            <mesh
              geometry={nodes.Object_34.geometry}
              material={materials["M_IRON.001"]}
            />
            <mesh
              geometry={nodes.Object_35.geometry}
              material={materials["interior3.002"]}
            />
            <mesh
              geometry={nodes.Object_36.geometry}
              material={materials["Car_window.001"]}
            />
          </group>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <mesh
              geometry={nodes.Object_38.geometry}
              material={materials["M_BODY_inside.001"]}
            />
            <mesh
              geometry={nodes.Object_39.geometry}
              material={materials["Car_body.001"]}
            />
            <mesh
              geometry={nodes.Object_40.geometry}
              material={materials["Car_window.001"]}
            />
            <mesh
              geometry={nodes.Object_41.geometry}
              material={materials["interior3.002"]}
            />
            <mesh
              geometry={nodes.Object_42.geometry}
              material={materials["M_BODY_black.001"]}
            />
          </group>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <mesh
              geometry={nodes.Object_44.geometry}
              material={materials["M_BODY_inside.001"]}
            />
            <mesh
              geometry={nodes.Object_45.geometry}
              material={materials["Car_body.001"]}
            />
            <mesh
              geometry={nodes.Object_46.geometry}
              material={materials["M_BODY_black.001"]}
            />
            <mesh
              geometry={nodes.Object_47.geometry}
              material={materials["M_IRON.001"]}
            />
            <mesh
              geometry={nodes.Object_48.geometry}
              material={materials["interior3.002"]}
            />
            <mesh
              geometry={nodes.Object_49.geometry}
              material={materials["Car_window.001"]}
            />
          </group>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <mesh
              geometry={nodes.Object_51.geometry}
              material={materials["M_BODY_inside.001"]}
            />
            <mesh
              geometry={nodes.Object_52.geometry}
              material={materials["Car_body.001"]}
            />
            <mesh
              geometry={nodes.Object_53.geometry}
              material={materials["Car_window.001"]}
            />
            <mesh
              geometry={nodes.Object_54.geometry}
              material={materials["interior3.002"]}
            />
          </group>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <mesh
              geometry={nodes.Object_12.geometry}
              material={materials["M_IRON.001"]}
            />
            <mesh
              geometry={nodes.Object_13.geometry}
              material={materials["M_ChePai.001"]}
            />
            <mesh
              geometry={nodes.Object_14.geometry}
              material={materials["M_LOGO.001"]}
            />
          </group>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <mesh
              geometry={nodes.Object_18.geometry}
              material={materials["Car_body.001"]}
            />
            <mesh
              geometry={nodes.Object_19.geometry}
              material={materials["M_BODY_inside.001"]}
            />
            <mesh
              geometry={nodes.Object_20.geometry}
              material={materials["M_BODY_black.001"]}
            />
            <mesh
              geometry={nodes.Object_21.geometry}
              material={materials["Car_window.001"]}
            />
            <mesh
              geometry={nodes.Object_22.geometry}
              material={materials["Car_backlight.001"]}
            />
            <mesh
              geometry={nodes.Object_23.geometry}
              material={materials["Car_lightglass.001"]}
            />
            <mesh
              geometry={nodes.Object_24.geometry}
              material={materials["Car_frontlight.001"]}
            />
            <mesh
              geometry={nodes.Object_25.geometry}
              material={materials["Car_radar.001"]}
            />
          </group>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <mesh
              geometry={nodes.Object_27.geometry}
              material={materials["M_BODY_black.001"]}
            />
            <mesh
              geometry={nodes.Object_28.geometry}
              material={materials["pasted__M_BODY_inside.002"]}
            />
            <mesh
              geometry={nodes.Object_29.geometry}
              material={materials["M_BODY_inside.001"]}
            />
          </group>
          <group rotation={[Math.PI / 2, 0, 0]} scale={0.01} ref={wheelRef}>
            <mesh
              geometry={nodes.Object_56001.geometry}
              material={materials["M_Wheel_ALL.001"]}
              position={[-94.355, 149.102, -33.663]}
            />
            <mesh
              geometry={nodes.Object_56002.geometry}
              material={materials["M_Wheel_ALL.001"]}
              position={[86.425, 145.446, -33.646]}
            />
            <mesh
              geometry={nodes.Object_56003.geometry}
              material={materials["M_Wheel_ALL.001"]}
              position={[86.42, -157.921, -33.652]}
            />
            <mesh
              geometry={nodes.Object_56004.geometry}
              material={materials["M_Wheel_ALL.001"]}
              position={[-94.372, -156.078, -33.678]}
            />
          </group>
          <mesh
            geometry={nodes.Object_4.geometry}
            material={materials["interior1.002"]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
          />
          <mesh
            geometry={nodes.Object_6.geometry}
            material={materials["interior2.002"]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
          />
          <mesh
            geometry={nodes.Object_8.geometry}
            material={materials["interior2.002"]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
          />
          <mesh
            geometry={nodes.Object_10.geometry}
            material={materials["interior4.002"]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
          />
          <mesh
            geometry={nodes.Object_16.geometry}
            material={materials["M_BODY_inside.001"]}
            rotation={[Math.PI / 2, 0, 0]}
            scale={0.01}
          />
        </group>
      </group>
      {/* <mesh
        geometry={nodes.topLigt.geometry}
        material={materials.Material_18}
        position={[-0.007, 11.686, -0.007]}
        scale={[27.643, 0.353, 17.251]}
      /> */}
      {/* <mesh rotation={[0, -Math.PI / 2, 0]} >
        {" "}
        <planeGeometry args={[10, 10]}></planeGeometry>
        <meshBasicMaterial side={THREE.DoubleSide}></meshBasicMaterial>
      </mesh> */}

      {/*  <mesh
        geometry={nodes.平面.geometry}
        material={materials.floor}
        scale={17.686}
      /> */}
    </group>
  );
}

useGLTF.preload("/models/car.glb");
