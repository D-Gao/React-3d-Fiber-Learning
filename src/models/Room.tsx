/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/models/sm_startroomraw.glb -o src/models/Room.tsx --typescript -r public 
*/

import * as THREE from "three";
import { useEffect, useRef } from "react";
import { MeshReflectorMaterial, useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { MeshReflectorMaterialProps } from "@react-three/drei/materials/MeshReflectorMaterial";

type GLTFResult = GLTF & {
  nodes: {
    light001: THREE.Mesh;
    ReflecFloor: THREE.Mesh;
  };
  materials: {
    light: THREE.MeshStandardMaterial;
    floor: THREE.MeshStandardMaterial;
  };
};

/* type RoomProps = JSX.IntrinsicElements["group"] & THREE.Texture; */

export function Room(props: any) {
  const { nodes, materials } = useGLTF(
    "/models/sm_startroomraw.glb"
  ) as GLTFResult;

  const [aoMap, lightMap, normalMap, roughnessMap] = useTexture([
    "/textures/su7/t_startroom_ao.raw.jpg",
    "/textures/su7/t_startroom_light.raw.jpg",
    "/textures/su7/t_floor_normal.webp",
    "/textures/su7/t_floor_roughness.webp",
  ]);

  const floorRef = useRef<MeshReflectorMaterialProps>(null);

  aoMap.wrapS = THREE.RepeatWrapping;
  aoMap.wrapT = THREE.RepeatWrapping;
  lightMap.wrapS = THREE.RepeatWrapping;
  lightMap.wrapT = THREE.RepeatWrapping;
  normalMap.wrapS = THREE.RepeatWrapping;
  normalMap.wrapT = THREE.RepeatWrapping;
  roughnessMap.wrapS = THREE.RepeatWrapping;
  roughnessMap.wrapT = THREE.RepeatWrapping;

  const floor = useRef<THREE.Mesh>(null);

  useEffect(() => {
    (floor.current!.material as THREE.MeshPhysicalMaterial).envMap =
      props.texture;

    (floor.current!.material as THREE.MeshPhysicalMaterial).envMapIntensity = 5;
    materials.light.side = THREE.DoubleSide;
    materials.light.transparent = true;
    //materials.light.opacity = 1;
    materials.light.emissive = new THREE.Color("white");
    materials.light.toneMapped = false;
    materials.light.emissiveIntensity = 0.9;

    materials.floor.aoMap = aoMap;
    materials.floor.aoMap.channel = 1;
    materials.floor.aoMap.flipY = false;
    materials.floor.aoMap.colorSpace = THREE.LinearSRGBColorSpace;
    console.log(props);

    materials.floor.lightMap = lightMap;
    materials.floor.lightMap.flipY = false;
    materials.floor.lightMap.channel = 1;
    /* materials.floor.lightMap.channel = 1;
    materials.floor.lightMap.flipY = false;
    materials.floor.lightMap.colorSpace = THREE.LinearSRGBColorSpace; */

    materials.floor.normalMap = normalMap;
    materials.floor.normalMap.wrapS = THREE.RepeatWrapping;
    materials.floor.normalMap.wrapT = THREE.RepeatWrapping;
    materials.floor.normalMap.flipY = false;
    materials.floor.normalMap.colorSpace = THREE.LinearSRGBColorSpace;

    materials.floor.roughnessMap = roughnessMap;
    materials.floor.roughnessMap.wrapS = THREE.RepeatWrapping;
    materials.floor.roughnessMap.wrapT = THREE.RepeatWrapping;
    materials.floor.roughnessMap.flipY = false;
    materials.floor.roughnessMap.colorSpace = THREE.LinearSRGBColorSpace;

    //lightMap.repeat.set(0.25, 0.75); // Use only the top half of the texture
    //lightMap.offset.set(0, 0); // Shift the texture up to show the top half
    /* floorRef.current!.lightMap = lightMap;
    floorRef.current!.lightMap.channel = 0;

    floorRef.current!.lightMap.flipY = false;
    floorRef.current!.lightMap.colorSpace = THREE.LinearSRGBColorSpace; */

    //floorRef.current!.lightMap.repeat.set(1, 0.5); // Adjust the repeat values as needed

    /*  floorRef.current!.aoMap = aoMap;
    floorRef.current!.aoMap.channel = 0;
    floorRef.current!.aoMap.flipY = false;
    floorRef.current!.aoMap.colorSpace = THREE.LinearSRGBColorSpace; */

    floorRef.current!.normalMap = normalMap;
    floorRef.current!.normalMap.wrapS = THREE.RepeatWrapping;
    floorRef.current!.normalMap.wrapT = THREE.RepeatWrapping;
    floorRef.current!.normalMap.flipY = false;
    floorRef.current!.normalMap.colorSpace = THREE.LinearSRGBColorSpace;
    //floorRef.current!.normalMap = normalMap;

    /* floorRef.current!.roughnessMap = roughnessMap;
    floorRef.current!.roughnessMap.wrapS = THREE.RepeatWrapping;
    floorRef.current!.roughnessMap.wrapT = THREE.RepeatWrapping;
    floorRef.current!.roughnessMap.flipY = false;
    floorRef.current!.roughnessMap.colorSpace = THREE.LinearSRGBColorSpace; */
  }, [props.texture]);
  return (
    <group {...props} dispose={null}>
      {/* <mesh
        geometry={nodes.light001.geometry}
        position={[0, 5.872, 0]}
        rotation={[-Math.PI, 0, Math.PI]}
        scale={2}
        material={materials.light}
      ></mesh> */}
      {/*  <mesh
        ref={floor}
        geometry={nodes.ReflecFloor.geometry}
        material={materials.floor}
        position={[-26, 0, -10]}
        rotation={[0, 0, 0]}
        scale={2.342}
      >
       
        <MeshReflectorMaterial
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ref={floorRef as React.Ref<any>}
          //color={new THREE.Color(1, 1, 1)}
          blur={[10, 10]}
          mixBlur={0}
          mixStrength={1}
          mixContrast={1}
          resolution={1024}
          mirror={0} // Mirror environment, 0 = texture colors, 1 = pick up env colors
          depthScale={0}
          minDepthThreshold={0.9}
          maxDepthThreshold={1}
          depthToBlurRatioBias={0.25}
          //envMapIntensity={1}
        />
      </mesh> */}

      <mesh
        rotation={[Math.PI / 2, Math.PI, 0]}
        ref={floor}
        position={[-5.5, 0, 5.5]}
        scale={0.8}
      >
        <planeGeometry args={[100, 100]}></planeGeometry>
        <MeshReflectorMaterial
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ref={floorRef as React.Ref<any>}
          /* color={new THREE.Color(1, 1, 1)} */
          blur={[10, 10]}
          mixBlur={0.5}
          mixStrength={1}
          mixContrast={1}
          resolution={512}
          mirror={1} // Mirror environment, 0 = texture colors, 1 = pick up env colors
          /* depthScale={0.1}
          minDepthThreshold={0.1}
          maxDepthThreshold={1}
          depthToBlurRatioBias={0.25} */
          //envMapIntensity={1}
        />
      </mesh>
    </group>
  );
}

useGLTF.preload("/models/sm_startroomraw.glb");
