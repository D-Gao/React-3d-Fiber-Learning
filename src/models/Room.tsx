/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/models/sm_startroomraw.glb -o src/models/Room.tsx --typescript -r public 
*/

import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useLoader } from "@react-three/fiber";
import { RGBELoader } from "three/examples/jsm/loaders/RGBELoader.js";

type GLTFResult = GLTF & {
  nodes: {
    light001: THREE.Mesh;
    ReflecFloor: THREE.Mesh;
  };
  materials: {
    light: THREE.MeshStandardMaterial;
    floor: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export function Room(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/models/sm_startroomraw.glb"
  ) as GLTFResult;

  const [aoMap, lightMap, normalMap, roughnessMap] = useTexture([
    "/textures/su7/t_startroom_ao.raw.jpg",
    "/textures/su7/t_startroom_light.raw.jpg",
    "/textures/su7/t_floor_normal.webp",
    "/textures/su7/t_floor_roughness.webp",
  ]);

  aoMap.wrapS = THREE.RepeatWrapping;
  aoMap.wrapT = THREE.RepeatWrapping;
  lightMap.wrapS = THREE.RepeatWrapping;
  lightMap.wrapT = THREE.RepeatWrapping;
  normalMap.wrapS = THREE.RepeatWrapping;
  normalMap.wrapT = THREE.RepeatWrapping;
  roughnessMap.wrapS = THREE.RepeatWrapping;
  roughnessMap.wrapT = THREE.RepeatWrapping;
  const hdrTexture = useLoader(RGBELoader, "/textures/su7/t_env_light.hdr");

  const floor = useRef<THREE.Mesh>(null);

  useEffect(() => {
    /* (floor.current!.material as THREE.MeshPhysicalMaterial).envMap = hdrTexture;
    (floor.current!.material as THREE.MeshPhysicalMaterial).envMapIntensity = 0; */
    materials.light.side = THREE.DoubleSide;
    materials.light.transparent = true;
    //materials.light.opacity = 1;
    materials.light.emissive = new THREE.Color("white");
    materials.light.toneMapped = false;
    materials.light.emissiveIntensity = 0.9;

    materials.floor.aoMap = aoMap;
    materials.floor.aoMap.channel = 1;
    materials.floor.aoMap.flipY = false;
    materials.floor.aoMap.colorSpace = THREE.LinearSRGBColorSpace;

    materials.floor.lightMap = lightMap;
    materials.floor.lightMap.channel = 1;
    materials.floor.lightMap.flipY = false;
    materials.floor.lightMap.colorSpace = THREE.LinearSRGBColorSpace;

    materials.floor.normalMap = normalMap;
    materials.floor.normalMap.wrapS = THREE.RepeatWrapping;
    materials.floor.normalMap.wrapT = THREE.RepeatWrapping;
    materials.floor.normalMap.flipY = false;
    materials.floor.normalMap.colorSpace = THREE.LinearSRGBColorSpace;

    materials.floor.roughnessMap = roughnessMap;
    materials.floor.roughnessMap.wrapS = THREE.RepeatWrapping;
    materials.floor.roughnessMap.wrapT = THREE.RepeatWrapping;
    materials.floor.roughnessMap.flipY = false;
    materials.floor.roughnessMap.colorSpace = THREE.LinearSRGBColorSpace;

    materials.floor.envMapIntensity = 0;
    //materials.floor.envMapIntensity = 0;

    /* (floor.current!.material as THREE.MeshPhysicalMaterial).aoMap!.repeat =
      new THREE.Vector2(2, 2); */
    /* (floor.current!.material as THREE.MeshPhysicalMaterial).envMapIntensity = 0;
    console.log(floor.current!.geometry.attributes.uv);
    console.log(floor.current!.geometry.attributes.uv2);
    console.log(floor.current); */

    //nodes.light001.rotateX(Math.PI / 3);
  }, []);
  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.light001.geometry}
        position={[0, 5.872, 0]}
        rotation={[-Math.PI, 0, Math.PI]}
        scale={2}
        material={materials.light}
      >
        {/* <meshBasicMaterial
          color={"white"}
          side={THREE.DoubleSide}
        ></meshBasicMaterial> */}
      </mesh>
      <mesh
        ref={floor}
        geometry={nodes.ReflecFloor.geometry}
        material={materials.floor}
        position={[28, 0, 11]}
        rotation={[Math.PI, 0, Math.PI]}
        scale={2.342}
      />
    </group>
  );
}

useGLTF.preload("/models/sm_startroomraw.glb");
