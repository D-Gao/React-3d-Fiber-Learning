/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/models/table.gltf -o src/models/Table.tsx --typescript -r public 
*/

import * as THREE from "three";
import { shaderMaterial, useGLTF } from "@react-three/drei";
import { Object3DNode, extend } from "@react-three/fiber";
import { GLTF } from "three-stdlib";
import { useEffect, useRef } from "react";
import { BufferGeometry, Points } from "three";
import { Camping } from "@/models/Camping.jsx";

type GLTFResult = GLTF & {
  nodes: Record<string, THREE.Mesh>;
  materials: {
    ["BrownDark.074"]: THREE.MeshStandardMaterial;
  };
};

// Vertex Shader
const vertexShader = `
  uniform float size;
  varying vec3 vColor;
  attribute vec3 color;

  void main() {
    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_PointSize = size * (300.0 / -mvPosition.z);
    gl_Position = projectionMatrix * mvPosition;
  }
`;

// Fragment Shader
const fragmentShader = `
  uniform vec3 color;
  varying vec3 vColor;

  void main() {
    float r = 0.5;
    vec2 uv = gl_PointCoord.xy - vec2(0.5);
    float dist = length(uv);

    if (dist < r) {
      gl_FragColor = vec4(vColor * color, 1.0);
    } else {
      discard;
    }
  }
`;

const CustomPointsMaterial = shaderMaterial(
  { color: new THREE.Color(0xffffff), size: 0.1 },
  vertexShader,
  fragmentShader
);

extend({
  CustomPointsMaterial,
});

declare module "@react-three/fiber" {
  interface ThreeElements {
    customPointsMaterial: Object3DNode<
      THREE.ShaderMaterial,
      typeof CustomPointsMaterial
    > /* &
      Partial<typeof uniformsProps>; */;
  }
}

export function ParticleCamping(props: JSX.IntrinsicElements["group"]) {
  const { nodes } = useGLTF(
    "/models/Camping Asset Collection.glb"
  ) as GLTFResult;

  const pointsRef = useRef<Points>(null);

  useEffect(() => {
    let allPositions: number[] = [];
    for (const key in nodes) {
      if (nodes[key].geometry) {
        const geometry = nodes[key].geometry;
        const positions = geometry.attributes.position.array;
        allPositions = allPositions.concat(Array.from(positions));
      }
    }

    /*   const positions = geometry.attributes.position.array; */
    const particlePositions = new Float32Array(allPositions.length);

    for (let i = 0; i < allPositions.length; i++) {
      particlePositions[i] = allPositions[i];
    }

    const particlesGeometry = new BufferGeometry();
    particlesGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(particlePositions, 3)
    );

    pointsRef.current!.geometry = particlesGeometry;
  }, [nodes]);

  return (
    <>
      <Camping />
      <points ref={pointsRef}>
        <bufferGeometry />
        <customPointsMaterial attach={"material"} />
        {/*   <pointsMaterial size={0.05} color={0xffffff} /> */}
      </points>
    </>
  );
}

useGLTF.preload("/models/table.gltf");

{
  /* <group {...props} dispose={null}>
      <mesh
        geometry={nodes.tableLarge.geometry}
        material={materials["BrownDark.074"]}
        rotation={[Math.PI / 2, 0, 0]}
      />
    </group> */
}
