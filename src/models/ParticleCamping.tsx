/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/models/table.gltf -o src/models/Table.tsx --typescript -r public 
*/

import * as THREE from "three";
import { Float, shaderMaterial, useGLTF } from "@react-three/drei";
import { Object3DNode, extend, useFrame, useThree } from "@react-three/fiber";
import { GLTF } from "three-stdlib";
import { useEffect, useRef } from "react";
import { BufferGeometry, Points } from "three";
import { Camping } from "@/models/Camping.jsx";

type GLTFResult = GLTF & {
  nodes: Record<string, THREE.Mesh>;
  materials: {
    ["BrownDark.074"]: THREE.MeshStandardMaterial;
  };
};

// Vertex Shader
const vertexShader = `
  uniform float size;
  uniform float time; // Add the time uniform
  varying vec3 vColor;
  attribute vec3 color;

  float randomx(float seed) {
    return sin(seed) * 43758.5453123;
  }

  void main() {
    vColor = color;
    
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    float rnd = randomx(position.x + position.y + position.z);
    gl_PointSize = size * (300.0 / -mvPosition.z) * abs(sin(time-rnd));
    gl_Position = projectionMatrix * mvPosition;
  }
`;

// Fragment Shader
const fragmentShader = `
  uniform vec3 color;
  varying vec3 vColor;

  void main() {
    float r = 0.5;
    vec2 uv = gl_PointCoord.xy - vec2(0.5);
    float dist = length(uv);

    if (dist < r) {
      gl_FragColor = vec4(vColor * color, 1.0);
    } else {
      discard;
    }
  }
`;

const CustomPointsMaterial = shaderMaterial(
  { color: new THREE.Color(0xffffff), size: 0.3, time: 0 },
  vertexShader,
  fragmentShader
);

extend({
  CustomPointsMaterial,
});

declare module "@react-three/fiber" {
  interface ThreeElements {
    customPointsMaterial: Object3DNode<
      THREE.ShaderMaterial,
      typeof CustomPointsMaterial
    > & { time: number };
  }
}

export function ParticleCamping(props: JSX.IntrinsicElements["group"]) {
  const { nodes } = useGLTF(
    "/models/Camping Asset Collection.glb"
  ) as GLTFResult;

  const state = useThree();

  const pointsRef = useRef<Points>(null);
  const materialRef = useRef<THREE.ShaderMaterial>(null);

  useEffect(() => {
    let allPositions: number[] = [];
    for (const key in nodes) {
      if (nodes[key].geometry) {
        const geometry = nodes[key].geometry;
        const positions = geometry.attributes.position.array;
        allPositions = allPositions.concat(Array.from(positions));
      }
    }

    /*   const positions = geometry.attributes.position.array; */
    const particlePositions = new Float32Array(allPositions.length);

    for (let i = 0; i < allPositions.length; i++) {
      particlePositions[i] = allPositions[i];
    }

    const particlesGeometry = new BufferGeometry();
    particlesGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(particlePositions, 3)
    );

    pointsRef.current!.geometry = particlesGeometry;
  }, [nodes]);

  useFrame(({ clock }) => {
    if (materialRef.current) {
      materialRef.current.uniforms.time.value = clock.getElapsedTime(); // Update the time uniform
    }
  });

  return (
    <>
      <Camping />

      <points ref={pointsRef}>
        <bufferGeometry />
        <customPointsMaterial
          ref={materialRef}
          attach={"material"}
          time={state.clock.getElapsedTime()}
        />
        {/*   <pointsMaterial size={0.05} color={0xffffff} /> */}
      </points>
    </>
  );
}

useGLTF.preload("/models/table.gltf");

{
  /* <group {...props} dispose={null}>
      <mesh
        geometry={nodes.tableLarge.geometry}
        material={materials["BrownDark.074"]}
        rotation={[Math.PI / 2, 0, 0]}
      />
    </group> */
}
