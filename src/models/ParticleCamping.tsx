/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/models/table.gltf -o src/models/Table.tsx --typescript -r public 
*/

import * as THREE from "three";
import { Float, shaderMaterial, useGLTF } from "@react-three/drei";
import { Object3DNode, extend, useFrame, useThree } from "@react-three/fiber";
import { GLTF } from "three-stdlib";
import { useEffect, useRef } from "react";
import { BufferGeometry, Points } from "three";
import { Camp } from "@/models/Camp";
import { lerp } from "three/src/math/MathUtils.js";
import { easing } from "maath";

type GLTFResult = GLTF & {
  nodes: Record<string, THREE.Mesh>;
  materials: {
    ["BrownDark.074"]: THREE.MeshStandardMaterial;
  };
};

// Vertex Shader
const vertexShader = /*glsl*/ `
  uniform float size;
  uniform float time; // Add the time uniform
  uniform vec2 mouse;
  varying vec3 vColor;
  attribute vec3 color;


  float randomx(float seed) {
    return sin(seed) * 43758.5453123;
  }

  void main() {
    vColor = color;
    
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);

    vec4 clipPosition =  projectionMatrix * mvPosition;

    float rnd = randomx(position.x + position.y + position.z);
    float dist = length(mouse - clipPosition.xy);
    float sizeModifier = 1.0/*  / (dist + 0.1) */;
    gl_PointSize = size * sizeModifier * (300.0 / -mvPosition.z) * abs(sin(time-rnd) );
    gl_Position = clipPosition;
  }
`;

// Fragment Shader
const fragmentShader = /*glsl*/ `
  uniform float opacity;
  uniform vec3 color;
  varying vec3 vColor;

  void main() {
    float r = 0.5;
    vec2 uv = gl_PointCoord.xy - vec2(0.5);
    float dist = length(uv);

    if (dist < r) {
      gl_FragColor = vec4(vColor * color, opacity);
    } else {
      discard;
    }
  }
`;

const objVertexShader = /*glsl*/ `
  uniform float size;
  uniform float time; // Add the time uniform
  uniform vec2 mouse;
  varying vec3 vColor;
  attribute vec3 color;


  float randomx(float seed) {
    return sin(seed) * 43758.5453123;
  }

  void main() {
    vColor = color;
    
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);

    vec4 clipPosition =  projectionMatrix * mvPosition;

    float rnd = randomx(position.x + position.y + position.z);
    float dist = length(mouse - clipPosition.xy);
    float sizeModifier = 1.0/*  / (dist + 0.1) */;
    gl_PointSize = size * sizeModifier * (300.0 / -mvPosition.z) /* * abs(sin(time-rnd) ) */;
    gl_Position = clipPosition;
  }
`;

// Fragment Shader
const objFragmentShader = /*glsl*/ `
  uniform vec3 color;
  varying vec3 vColor;

  void main() {
    float r = 0.5;
    vec2 uv = gl_PointCoord.xy - vec2(0.5);
    float dist = length(uv);

    if (dist < r) {
      gl_FragColor = vec4(vColor * color, 1.0);
    } else {
      discard;
    }
  }
`;

const CustomPointsMaterial = shaderMaterial(
  {
    color: new THREE.Color(0xffffff),
    size: 0.3,
    time: 0,
    mouse: new THREE.Vector2(0, 0),
    opacity: 1,
  },
  vertexShader,
  fragmentShader
);

const CustomShaderMaterial = shaderMaterial(
  {
    color: new THREE.Color(0xffffff),
    size: 0.3,
    time: 0,
    mouse: new THREE.Vector2(0, 0),
    opacity: 1,
  },
  objVertexShader,
  objFragmentShader
);

extend({
  CustomPointsMaterial,
});

declare module "@react-three/fiber" {
  interface ThreeElements {
    customPointsMaterial: Object3DNode<
      THREE.ShaderMaterial,
      typeof CustomPointsMaterial
    > /* & { time: number } */;
  }
}

export function ParticleCamping(props: JSX.IntrinsicElements["group"]) {
  const { nodes } = useGLTF(
    "/models/Camping Asset Collection.glb"
  ) as GLTFResult;

  const state = useThree();

  const pointsRef = useRef<Points>(null);
  const pointsMaterialRef = useRef<THREE.ShaderMaterial>(null);
  const shaderMaterialRef = useRef<THREE.ShaderMaterial>(null);
  const hoverRef = useRef<boolean>(false);
  const campRef = useRef<THREE.Group>(null);

  useEffect(() => {
    const sign = hoverRef.current ? 1 : 0;

    /* campRef.current?.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        child.material.transparent = true;
        child.material.opacity = 0;
        child.material.needsUpdate = true;
      }
    }); */

    let allPositions: number[] = [];
    for (const key in nodes) {
      if (nodes[key].geometry) {
        const geometry = nodes[key].geometry;
        const positions = geometry.attributes.position.array;
        allPositions = allPositions.concat(Array.from(positions));
      }
    }

    const particlePositions = new Float32Array(allPositions.length);

    for (let i = 0; i < allPositions.length; i++) {
      particlePositions[i] = allPositions[i];
    }

    const particlesGeometry = new BufferGeometry();
    particlesGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(particlePositions, 3)
    );

    pointsRef.current!.geometry = particlesGeometry;
  }, [nodes]);

  useFrame(({ clock }, delta) => {
    console.log(delta);
    if (pointsMaterialRef.current) {
      pointsMaterialRef.current.uniforms.time.value = clock.getElapsedTime(); // Update the time uniform
      /* pointsMaterialRef.current.uniforms.opacity.value = hoverRef.current
        ? 1
        : 0; */

      easing.damp(
        pointsMaterialRef.current,
        "opacity",
        hoverRef.current ? 0 : 1,
        0.2,
        delta
      );
      easing.damp(
        pointsMaterialRef.current,
        "size",
        hoverRef.current ? 0 : 0.3,
        0.2,
        delta
      );
    }

    const sign = hoverRef.current ? 1 : -1;
    campRef.current?.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        if (child.material.opacity <= 1 && child.material.opacity >= 0) {
          child.material.transparent = true;
          const temp: number = child.material.opacity + 0.1 * delta * sign;

          child.material.opacity = Math.max(Math.min(temp, 1), 0);
          child.material.depthWrite = false;
          child.material.needsUpdate = true;
        }
      }
    });

    //lerp(pointsMaterialRef.current!.opacity, hoverRef.current ? 1 : 0, 0);
  });

  return (
    <>
      <Camp
        ref={campRef}
        onPointerEnter={() => {
          console.log("sdasdsa");
          hoverRef.current = true;
        }}
        onPointerLeave={() => {
          console.log("leave");
          hoverRef.current = false;
        }}
      >
        {/* <customPointsMaterial
          ref={shaderMaterialRef}
          attach={"material"}
         
        /> */}
      </Camp>

      <points ref={pointsRef}>
        {/* <bufferGeometry /> */}
        <customPointsMaterial
          transparent={true}
          ref={pointsMaterialRef}
          attach={"material"}
        />
      </points>
    </>
  );
}

useGLTF.preload("/models/table.gltf");

{
  /* <group {...props} dispose={null}>
      <mesh
        geometry={nodes.tableLarge.geometry}
        material={materials["BrownDark.074"]}
        rotation={[Math.PI / 2, 0, 0]}
      />
    </group> */
}
